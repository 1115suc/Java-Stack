# 🦒 Zookeeper 使用

## 🐳 Docker 部署

```shell
docker pull zookeeper:3.7.2
```
```shell
docker cp zookeeper:/conf /root/zookeeper/node-1/conf 
```
```shell
docker run -d \
  --name zookeeper \
  --hostname zookeeper \
  -p 2181:2181 \
  -e TZ="Asia/Shanghai" \
  -v /root/zookeeper/node-1/data:/data \
  -v /root/zookeeper/node-1/conf:/conf \
  zookeeper:3.7.2
```


## 📊 Zookeeper 数据结构

- ZooKeeper数据模型的结构与Unix文件系统很类似，整体上可以看作是一棵树，每个节点称做一个ZNode，每个ZNode都可以通过其路径唯一标识

![fcfaaf51f3deb48f36625a57fa1f3a292df57834.png](img/fcfaaf51f3deb48f36625a57fa1f3a292df57834.png)

### 🎯 Znode 节点类型

- **持久化目录节点（PERSISTENT）**
    - 客户端与zookeeper断开连接后，该节点依旧存在
- **持久化顺序编号目录节点（PERSISTENT_SEQUENTIAL）**
    - 客户端与zookeeper断开连接后，该节点依旧存在，Zookeeper会给该节点按照顺序编号
- **临时目录节点（EPHEMERAL）**
    - 客户端与zookeeper断开连接后，该节点被删除
- **临时顺序编号目录节点（EPHEMERAL_SEQUENTIAL）**
    - 客户端与zookeeper断开连接后，该节点被删除，Zookeeper会给该节点按照顺序编号

## 🛠️ Zookeeper 命令

- **1.** 使用 `ls` 命令来查看当前znode中所包含的内容

```shell
ls path [watch]
```


- **2.** 查看当前节点数据并能看到更新次数等数据

```shell
ls2 path [watch]
```


- **3.** 创建节点 -s 含有序列 -e 临时 acl 权限

```shell
create [-s] [-e] path data acl
```


- **4.** 获得节点的值

```shell
get path [watch]
```


- **5.** 设置节点的值 version 版本号

```shell
set path data [version]
```


- **6.** 查看节点状态

```shell
stat path [watch]
```


- **7.** 删除节点

```shell
delete path [version]
```


- **8.** 递归删除节点

```shell
rmr path
```


## 💻 Zookeeper API 使用

### 📦 引入依赖

```xml
    <dependency>
        <groupId>org.apache.zookeeper</groupId>
        <artifactId>zookeeper</artifactId>
        <version>3.7.2</version>
    </dependency>
```


### 🔧 主要 API 方法

#### 🚀 连接创建
```java
    ZooKeeper zk = new ZooKeeper(String connectString, int sessionTimeout, Watcher watcher)
```


> - 创建zookeeper连接
> - `connectString`表示连接的zookeeper服务器的地址
> - `sessionTimeOut`指定会话的的超时时间
> - `Watcher`配置监听

#### 📝 节点创建
```java
    String create(String path, byte[] data, List acl,CreateMode createMode)
```


> - 创建一个给定的目录节点 `path`, 并给它设置数据
> - `CreateMode` 标识有 四种形式的目录节点
    >   - `PERSISTENT`：持久化目录节点，这个目录节点存储的数据不会丢失；
>   - `PERSISTENT_SEQUENTIAL`：顺序自动编号的目录节点，这种目录节点会根据当前已近存在的节点数自动加 1，然后返回给客户端已经成功创建的目录节点名；
>   - `EPHEMERAL`：临时目录节点，一旦创建这个节点的客户端与服务器端口也就是 session 超时，这种节点会被自动删除；
>   - `EPHEMERAL_SEQUENTIAL`：临时自动编号节点

#### 🔍 节点检查
```java
    Stat exists(String path, boolean watch)
```


> - 判断某个 `path` 是否存在，并设置是否监控这个目录节点
> - 这里的 `watcher` 是在创建 `ZooKeeper` 实例时指定的 `watcher`，
> - `exists` 有一个重载方法，可以指定特定的watcher

```java
    Stat exists(String path,Watcher watcher)
```


> - 重载方法，这里给某个目录节点设置特定的 `watcher`
> - `Watcher` 在 ZooKeeper 是一个核心功能，`Watcher` 可以监控目录节点的数据变化以及子目录的变化，一旦这些状态发生变化，服务器就会通知所有设置在这个目录节点上的 `Watcher`，从而每个客户端都很快知道它所关注的目录节点的状态发生变化，而做出相应的反应

#### 🗑️ 节点删除
```java
    void delete(String path, int version)
```


> - 删除 `path` 对应的目录节点，`version` 为 -1 可以匹配任何版本，也就删除了这个目录节点所有数据

#### 🔍 获取子节点
```java
    List<String> getChildren(String path, boolean watch)
```


> 获取指定 `path` 下的所有子目录节点，同样 `getChildren`方法也有一个重载方法可以设置特定的 `watcher` 监控子节点的状态

#### ✏️ 设置节点数据
```java
    Stat setData(String path, byte[] data, int version)
```


> - 给 `path` 设置数据，可以指定这个数据的版本号，如果 `version` 为 -1 怎可以匹配任何版本

#### 📖 获取节点数据
```java
    byte[] getData(String path, boolean watch, Stat stat)
```


> - 获取这个 `path` 对应的目录节点存储的数据，数据的版本等信息可以通过 `stat` 来指定，同时还可以设置是否监控这个目录节点数据的状态

---

#### 🎯 Watcher 机制
- **事件类型**：`NodeCreated`, `NodeDeleted`, `NodeDataChanged`, `NodeChildrenChanged`
- **一次性触发**：watcher是一次性的，触发后需要重新注册
- **异步通知**：事件通知是异步发送给客户端的

#### 🔐 ACL 权限控制
- **OPEN_ACL_UNSAFE**: 完全开放的ACL，任何用户都可以操作
- **CREATOR_ALL_ACL**: 创建者拥有所有权限
- **READ_ACL_UNSAFE**: 只读权限

#### ⚡ 连接状态管理
- **CONNECTING**: 连接中状态
- **CONNECTED**: 已连接状态
- **CLOSED**: 连接关闭状态
- **AUTH_FAILED**: 认证失败状态